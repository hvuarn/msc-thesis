---
title: "07_ghcm"
date: "2025-07-02"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(readr)
library(glue)
library(purrr)
library(mgcv)
library(xtable)
library(kableExtra)
library(lubridate)
library(ghcm)
library(refund)
library(tidyr)
library(fdapace)
library(ggplot2)
library(latex2exp) 
```

## GHCM test: StudentLife 2013

This script runs the GHCM test to assess whether passively sensed physical activity is conditionally independent of follow-up depression, given baseline depression and other functional covariates (conversation duration and phone lock duration).

```{r}
# Make sure that Knit Directory is set to Project Directory! 
# Knit ▸ Knit Directory ▸ Project Directory

rm(list = ls())

# load
activity <- readRDS("data/studentlife_2013/preprocessed/joint/activity_filtered.rds")
overview <- readRDS("data/studentlife_2013/preprocessed/joint/overview_complete.rds")
convo <- readRDS("data/studentlife_2013/preprocessed/sensing/convo/convo_clean.rds")
phonelock <- readRDS("data/studentlife_2013/preprocessed/sensing/phonelock/phonelock_clean.rds")

# common .obs across X, Y, Z, X_-j
common_obs <- Reduce(intersect, list(
  unique(activity$.obs),
  unique(convo$.obs),
  unique(phonelock$.obs),
  overview$.obs
))

activity_use <- activity %>% filter(.obs %in% common_obs)
convo_use <- convo %>% filter(.obs %in% common_obs)
phonelock_use <- phonelock %>% filter(.obs %in% common_obs)
overview_use <- overview %>% filter(.obs %in% common_obs)

save_path <- "data/studentlife_2013/preprocessed/results/analysis_02"
if (!dir.exists(save_path)) dir.create(save_path, recursive = TRUE)

```


```{r}
# -------------------------------------------
# map .obs to obs_index
# -------------------------------------------
obs_map <- overview_use %>% 
	arrange(.obs) %>% 
	mutate(obs_index = row_number()) %>%
  dplyr::select(.obs, obs_index)

activity_fixed <- activity_use %>%
  inner_join(obs_map, by = ".obs") %>%
  dplyr::select(.obs = obs_index, .index, .value)

convo_fixed <- convo_use %>%
  inner_join(obs_map, by = ".obs") %>%
  dplyr::select(.obs = obs_index, .index, .value)

phonelock_fixed <- phonelock_use %>%
  inner_join(obs_map, by = ".obs") %>%
  dplyr::select(.obs = obs_index, .index, .value)

overview_fixed <- overview_use %>%
  inner_join(obs_map, by = ".obs") %>%
  arrange(obs_index)

overview_df <- as.data.frame(overview_fixed)
rownames(overview_df) <- overview_fixed$obs_index

```



```{r}
# ===================================================
# 1. GHCM: X ⫫ Y | Z <- basic baseline test (this is the same as 04_ghcm!)
# ===================================================

# 1: Y ~ Z scalar-on-scalar
model_Y <- gam(phq9_post ~ s(phq9_pre), data = overview_fixed)
resid_Y <- resid(model_Y)

# 2: X ~ Z function-on-scalar
model_X <- pffr(
  .value ~ s(phq9_pre),
  ydata = activity_fixed,
  data = overview_df
)
resid_X <- residuals(model_X)

# ghcm
X_limits <- range(activity_fixed$.index)

ghcm_result <- ghcm_test(
  resid_X,
  resid_Y,
  X_limits = X_limits
)

print.default(ghcm_result)
```


```{r}
# ================================================================= #
# Methodological note on functional covariates
# ================================================================= #
#
# Initial attempts to model functional covariates like conversation
# duration using simpler methods (e.g., pfr with ff() terms)
# were unsuccessful due to the sparse, irregular nature of the data,
# which led to rank-deficiency issues.
#
# To address this, we use Functional Principal Component Analysis (FPCA)
# via the `fdapace` package. As described in its documentation, this
# method is ideal for sparse functional data as it does not rely on
# pre-smoothing individual trajectories and can handle irregular
# observation schedules.
#
# We extract the FPC scores for each participant and use them as
# scalar predictors in the subsequent GAM and pffr models.
#
# ================================================================= 
# ff(convo) 
# warning message: "low rank! almost no truly independent variation across students. 
# not enough unique shapes across students! ffpc might be better"

# ffpc did not work with NA -> imputed! ...kind of bad
# let us keep the long format, sparse, irregular (and could even handle NA!)

# lf() with pfr() needs wide matrix of convo features

# SOLUTION: use fdapace! sparse, irregular; we can use long format
# such that we don't have to impute missingess in wide matrix!

# vignette fdpace: 
# For sparse designs, it provides fitted continuous trajectories with confidence bands, even for subjects with very few longitudinal observations. …PACE is based on the idea that observed functional data are generated by a sample of underlying (but usually not fully observed) random trajectories that are realizations of a stochastic process. It does not rely on pre-smoothing of trajectories, which is problematic if functional data are sparsely sampled.
# concurrent (varying coefficient) regression models for sparse and dense designs
# optimal designs for longitudinal data analysis (for trajectory prediction and for functional linear regression
```



```{r}
# ===========================================================
# FPCA: convo
# ===========================================================

# convo as functional predictor (long format)
convo_ydata <- convo_fixed %>%
  dplyr::select(.obs, .index, .value)

# check missing
stopifnot(sum(is.na(convo_ydata$.value)) == 0)

# convert to list form for FPCA
Ly <- split(convo_ydata$.value, convo_ydata$.obs)
Lt <- split(convo_ydata$.index, convo_ydata$.obs)

# run FPCA
set.seed(123) 
fpca_res <- fdapace::FPCA(Ly = Ly, Lt = Lt, optns = list(dataType = "Sparse"))

# determine how many FPCs to keep (> 99% variance)
n_keep <- which(fpca_res$cumFVE >= 0.99)[1]

# extract scores
fpc_scores <- fpca_res$xiEst[, 1:n_keep, drop = FALSE]
colnames(fpc_scores) <- paste0("FPC", 1:n_keep)
fpc_scores <- data.frame(.obs = as.integer(names(Ly)), fpc_scores)


# !--------- check (added, 29.7)----------
fpca_res          
dim(fpca_res$xiEst)     
is.matrix(fpca_res$xiEst)
is.array(fpca_res$xiEst)

n_keep                         
summary(fpc_scores)             
dim(fpc_scores)                 
class(fpc_scores)               
summary(fpc_scores$FPC1) # example FPC1¨ 
dim(fpc_scores$FPC1)
fpc_scores$FPC1
# !-------------------------------------------


# restrict to obs used in FPCA
obs_keep <- fpc_scores$.obs

# scalar data + FPCs
model_data <- overview_df %>%
  dplyr::filter(obs_index %in% obs_keep) %>%
  dplyr::mutate(.obs = obs_index) %>%
  dplyr::select(.obs, phq9_pre, phq9_post) %>%
  dplyr::left_join(fpc_scores, by = ".obs")

# functional outcome
activity_ydata <- activity_fixed %>%
  dplyr::filter(.obs %in% obs_keep)
```



```{r}
# -------------------------------------------------------
# FPCA: phonelock
# -------------------------------------------------------
phonelock_ydata <- phonelock_fixed %>%
  dplyr::select(.obs, .index, .value)

stopifnot(sum(is.na(phonelock_ydata$.value)) == 0)

Ly_ph <- split(phonelock_ydata$.value, phonelock_ydata$.obs)
Lt_ph <- split(phonelock_ydata$.index, phonelock_ydata$.obs)

# needs to be sorted for next call; sort Lt_ph and Ly_ph together by time
Lt_ph_sorted <- lapply(Lt_ph, sort)
Ly_ph_sorted <- Map(function(t, y) y[order(t)], Lt_ph, Ly_ph)
Lt_ph_sorted <- lapply(Lt_ph, sort)  # re-assign just to be explicit
```

```{r}
# this will take a while!
set.seed(123) 
fpca_ph <- fdapace::FPCA(Ly = Ly_ph_sorted, Lt = Lt_ph_sorted, optns = list(dataType = "Sparse")) 
saveRDS(fpca_ph, file = "data/studentlife_2013/preprocessed/results/analysis_01/fpca_phonelock.rds")
```

```{r}
fpca_ph <- readRDS("data/studentlife_2013/preprocessed/results/analysis_01/fpca_phonelock.rds")

# !--------- check (added, 29.7)----------
fpca_ph
dim(fpca_ph$xiEst)
summary(fpca_ph$xiEst)
class(fpca_ph$xiEst)
#fpca_res$cumFVE

# keep FPCs for > 99% variance
n_keep_ph <- which(fpca_ph$cumFVE >= 0.99)[1]

# extract scores
fpc_scores_ph <- fpca_ph$xiEst[, 1:n_keep_ph, drop = FALSE]
colnames(fpc_scores_ph) <- paste0("PH_FPC", 1:n_keep_ph)
fpc_scores_ph <- data.frame(.obs = as.integer(names(Ly_ph)), fpc_scores_ph)

# keep overlapping obs
obs_keep <- intersect(model_data$.obs, fpc_scores_ph$.obs)

# update model data
model_data_ext <- model_data %>%
  filter(.obs %in% obs_keep) %>%
  left_join(fpc_scores_ph, by = ".obs")

activity_ydata_ext <- activity_fixed %>%
  filter(.obs %in% obs_keep)
```


```{r}
# create predictor list dynamically
rhs_X <- paste(
  c("phq9_pre", 
    paste0("FPC", 1:n_keep), 
    paste0("PH_FPC", 1:n_keep_ph)),
  collapse = " + "
)

rhs_Y <- paste(
  c("s(phq9_pre)", 
    paste0("FPC", 1:n_keep), 
    paste0("PH_FPC", 1:n_keep_ph)),
  collapse = " + "
)


fml_X <- as.formula(paste(".value ~", rhs_X))
fml_Y <- as.formula(paste("phq9_post ~", rhs_Y))
```



```{r}
# ===========================================================
# 2. GHCM: X ⫫ Y | X_-j, Z 
# X_-j: convo, phonelock via FPCA
# ==========================================================

# 1. scalar on "function": GAM!
model_Y <- gam(
  formula = fml_Y, # phq9_post ~ s(phq9_pre) + FPC1 + FPC2 + FPC3 + FPC4
  data = model_data_ext
)
resid_Y <- residuals(model_Y)


# 2. function on "function": function on scalar
model_X <- pffr(
  formula = fml_X, # .value ~ s(phq9_pre) + FPC1 + FPC2 + FPC3 + FPC4
  data = model_data_ext,
  ydata = activity_ydata_ext
)
resid_X <- residuals(model_X)


ghcm_result <- ghcm_test(
  resid_X,
  resid_Y,
  X_limits = range(activity_fixed$.index)
)

print.default(ghcm_result)
saveRDS(ghcm_result, file = file.path(save_path, "ghcm_result.rds"))
ghcm_summary <- list( 
	test_statistic = round(ghcm_result$test_statistic, 3),
	p_value = round(ghcm_result$p, 3),
	alpha = ghcm_result$alpha,
	reject = ghcm_result$reject
)
saveRDS(ghcm_summary, file = file.path(save_path, "ghcm_summary.rds"))
```

```{r}
summary(model_Y)
plot(model_Y)

# gam
pdf(file.path(save_path, "gam_plot.pdf"), width = 7, height = 5)
plot(model_Y, residuals = TRUE, se = TRUE)  
dev.off()

pdf(file.path(save_path, "gam_check.pdf"), width = 7, height = 5)
par(mfrow = c(2, 2))           
gam.check(model_Y, pages = 0)   
dev.off()

```


```{r}
summary(model_X)
plot(model_X)

# pffr plot 
pdf(file.path(save_path, "pffr_plot.pdf"), width = 8, height = 10)
par(mfrow = c(4, 2))
plot(model_X, pages = 0)
dev.off()

# pffr check
pdf(file.path(save_path, "pffr_check.pdf"), width = 7, height = 5)
par(mfrow = c(2, 2))
pffr.check(model_X)
dev.off()
```

```{r}
# ==========================================================
# bootstrap for GHCM test (2)
# ==========================================================

# prepare inputs
Z_df_ext <- model_data_ext %>%
  as.data.frame()
rownames(Z_df_ext) <- Z_df_ext$.obs

Y_df_ext <- model_data_ext %>%
  dplyr::select(.obs, phq9_post)

X_fixed_ext <- activity_ydata_ext

# bootstrap function for GHCM with X_-j
bootstrap_ghcm <- function(i) {
  obs_ids <- sample(seq_len(nrow(Z_df_ext)), replace = TRUE)
  sampled_obs <- as.integer(rownames(Z_df_ext)[obs_ids])
  
  obs_map <- data.frame(.obs = sampled_obs) %>%
    distinct(.obs, .keep_all = TRUE) %>%
    mutate(obs_index = row_number())
  
  Zb <- model_data_ext[as.character(obs_map$.obs), , drop = FALSE]
  Zb$obs_index <- obs_map$obs_index
  Zb$phq9_pre <- as.numeric(Zb$phq9_pre)  
  rownames(Zb) <- Zb$obs_index

  Xb <- X_fixed_ext %>%
    inner_join(obs_map, by = ".obs") %>%
    dplyr::select(.obs = obs_index, .index, .value)
  
  Yb <- Y_df_ext %>%
    inner_join(obs_map, by = ".obs") %>%
    arrange(.obs) %>%
    dplyr::pull(phq9_post)
  
  model_Xb <- pffr(formula = fml_X, ydata = Xb, data = Zb)
  resid_Xb <- residuals(model_Xb)
  
  model_Yb <- tryCatch(
  gam(phq9_post ~ s(phq9_pre) + FPC1 + PH_FPC1, data = Zb),
  error = function(e) lm(phq9_post ~ phq9_pre + FPC1 + PH_FPC1, data = Zb))

  resid_Yb <- resid(model_Yb)
  
  ghcm_test(resid_Xb, resid_Yb, X_limits = range(Xb$.index))$p
}

# run bootstrap
set.seed(123)
B <- 100
p_values <- future_map_dbl(1:B, bootstrap_ghcm, .options = furrr_options(seed = TRUE))

saveRDS(p_values, file = file.path(save_path, glue::glue("p_values_B{B}.rds")))
```


```{r}
# load p-values
B <- 100
p_vals_2 <- readRDS(file.path(save_path, glue::glue("p_values_B{B}.rds")))

# compute summary statistics
ci_p_2 <- quantile(p_vals_2, probs = c(0.025, 0.975))
p_mean_2 <- mean(p_vals_2)

# save summary
summary_ghcm_boot_2 <- list(
  mean_p = round(p_mean_2, 3),
  ci_lower = round(ci_p_2[1], 3),
  ci_upper = round(ci_p_2[2], 3),
  B = B
)
saveRDS(summary_ghcm_boot_2, file = file.path(save_path, "ghcm_boot_summary.rds"))
```


```{r}
# plot ECDF
df_p_2 <- data.frame(p_value = p_vals_2)

plot_ecdf <- ggplot(df_p_2, aes(x = p_value)) +
  stat_ecdf(geom = "step", size = 1.3, color = "darkorange") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  geom_vline(xintercept = 0.05, linetype = "dashed", color = "gray") +
	labs(x = expression("Bootstrapped "*italic("p")*"-value"), y = "ECDF") +
  coord_cartesian(xlim = c(0, 1), ylim = c(0, 1)) +
  theme_minimal(base_size = 11) +
  theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.5),
    axis.line = element_blank()
  )
print(plot_ecdf)
ggsave(file.path(save_path, "plot_ecdf.pdf"), plot = plot_ecdf, width = 6, height = 4)
```



tried to do facet wrap plots with fancy labels, but looks shitty.

```{r}
# ======================================================
# ECDF for GHCM analysis 01 vs analysis 02 (faceted)
# ======================================================

# load p-values
p_vals_1 <- readRDS("data/studentlife_2013/preprocessed/results/analysis_01/p_values_B100.rds")
p_vals_2 <- readRDS("data/studentlife_2013/preprocessed/results/analysis_02/p_values_B100.rds")

df_p <- bind_rows(
  data.frame(p_value = p_vals_1, setting = "1"),
  data.frame(p_value = p_vals_2, setting = "2")
)

df_p$setting <- factor(df_p$setting, levels = c("1", "2"),
  labels = c("Z: baseline", "Z: baseline, convo, phonelock")
)

plot_ecdf2 <- ggplot(df_p, aes(x = p_value)) +
  stat_ecdf(geom = "step", size = 1.3, color = "darkgreen") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  geom_vline(xintercept = 0.05, linetype = "dashed", color = "gray") +
  facet_wrap(~setting) + 
  labs(x = expression(italic("p")*"-value"), y = "ECDF") +
  coord_cartesian(xlim = c(0, 1), ylim = c(0, 1)) +
  theme_bw() +
  theme(
    panel.grid.minor = element_blank(),
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.4),
    strip.text = element_text(size = 12)
  )
print(plot_ecdf2)
ggsave(file.path(save_path, "plot_ecdf2.pdf"), plot = plot_ecdf2, width = 7, height = 4)

```


```{r}

p_vals_1 <- readRDS("data/studentlife_2013/preprocessed/results/analysis_01/p_values_B100.rds")
p_vals_2 <- readRDS("data/studentlife_2013/preprocessed/results/analysis_02/p_values_B100.rds")

df_p <- bind_rows(
  data.frame(p_value = p_vals_1, setting = "Simple Model"),
  data.frame(p_value = p_vals_2, setting = "Full Model")
)
tex_labels <- c(
  `Simple Model` = "$Y$ \\perp $X_{j}$\\ |  $Z$",
  `Full Model`   = "$Y$ \\perp $X_{j}$\\ |  $X_{-j}$,\\ $Z$"
)

df_p <- df_p %>%
  mutate(setting = factor(setting, 
                          levels = names(tex_labels), 
                          labels = sapply(tex_labels, TeX, output = 'expression')))

plot_ecdf3 <- ggplot(df_p, aes(x = p_value)) +
  stat_ecdf(geom = "step", linewidth = 1.2, color = "darkgreen") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  geom_vline(xintercept = 0.05, linetype = "dotted", color = "gray") +
  facet_wrap(~ setting, labeller = label_parsed) +
  labs(x = expression(italic("p")*"-value"), y = "ECDF") +
  coord_cartesian(xlim = c(0, 1), ylim = c(0, 1)) +
  theme_bw() +
  theme(
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 12),
    strip.background = element_rect(fill="grey90", color="black")
  )
print(plot_ecdf3)
ggsave(file.path(save_path, "plot_ecdf3.pdf"), plot = plot_ecdf3, width = 7, height = 4)
```




